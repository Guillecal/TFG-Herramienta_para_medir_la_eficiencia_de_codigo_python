\capitulo{3}{Conceptos teóricos}


Algunos conceptos teóricos de \LaTeX \footnote{Créditos a los proyectos de Álvaro López Cantero: Configurador de Presupuestos y Roberto Izquierdo Amo: PLQuiz}.

\section{Fundamentos Basicos}

\subsection{La eficiencia}

La eficiencia vista desde un ámbito general se definiría como el uso racionado de los recursos para conseguir un objetivo x. Esta definición puede ser aplicado a cualquier ámbito en el que se hable de eficiencia pero en el caso de este proyecto se aplicara esta definición en el ámbito computacional.
La definición citada anteriormente menciona la palabra recursos, en el ámbito computacional, cuando se habla de recursos la palabra que más suele asociarse es tiempo. Esto no quiere decir que sea la única medida de eficiencia, ni mucho menos, también se podría poner como recurso el espacio en memoria, por ejemplo, pero el tiempo suele ser el recurso que más condiciona y la gente más en cuenta tiene en los procesos computacionales.\\
Aquí llegamos a la razón de existir de este proyecto, ¿cómo medimos lo que tarda un programa en ejecutarse de manera fiable? La manera más extendida para hacer esto, es ejecutar el programa del cual se quiera saber cuánto tiempo y esperar a que termine contado el tiempo pasado desde el comienzo hasta el final de este. Esta manera a pesar de ser sencilla, a la hora de la verdad es muy poco fiable, para que los resultados obtenidos por este método sean considerados verídicos se tendría que asegurar que el entorno de pruebas tiene unas condiciones idóneas, como por ejemplo que el procesador que del ordenador donde se ejecuta el programa no este gastando recursos en otros procesos que estén activos en segundo plano. El problema de esto es que conseguir un entorno así muchas veces no es tarea fácil. Y como respuesta a este problema surge la idea principal de este proyecto, medir la eficiencia de un programa de una manera fiable, que no se vea afectado por factores externos a este.\\
Para lograr un método de medir la eficiencia de un programa sin que su valor se vea afectado por el cuándo y dónde se haga el análisis, se decidió hacerlo a través de las operaciones que se ejecutan en el código del programa. Y una vez sacados ponderarlos según la complejidad de cada uno. 

\subsection{El interprete}

Un interprete es un programa que analiza y ejecuta el código de otro programa instruccion a instruccion. Esta es la manera con la que se pueden detectar los diferentes elementos que componen un programa. Al realizar este programa en Python hay que comentar antes que se trata de una maquina de pilas, lo que no deja de ser una maquina virtual que emula el funcionamiento de un ordenador. El funcionamiento principal de este se basa en almacenar y gestionar información que va recogiendo, en las diversas pilas que tiene, para de esta manera poder hacer sus operaciones.\\
El interprete elegido para esta practica se trata de ByteRun, un interprete hecho en codigo python y para código python. Este interprete fue elegido porque al tener como objetivo principal el aprendizaje, su complejidad no es muy alta y por lo tanto es relativamente facil implementar nuevas funcionalidades en este. Por otro lado en contra parte de esa baja complejidad hay que mencionar que ByteRun no es un inteprete muy rápido, como por ejemplo podría ser Cpython, pero como en este trabajo el principal requisito que se busca en un interprete es el de poder implementar en este, una forma de poder detectar las operaciones ejecutadas y porder guardarlas, el ByteRun era una opcion muy acertada que se adaptaba perfectamente a los qrequisitos del desarrollo.


\subsection{Bytecode}.
El Bytecode al ser un interprete de Python, no analiza directamente el codigo de alto nivel, lo que analiza este es un codigo intermerdio llamado Bytecode, el cual se trata de un codigo intermedio sacado a traves de la traduccion de codigo de alto nivel al ser pasado este por una serie de procesos (lexin,..,..).

Foto deun Byte code
antes del dis y despues


\section{De ByteCode a una medida de eficiencia}

Como bien se ha comentado antes, una vez obtenido el Bytecode, el interprete, en nuestro caso el ByteRun, es capaz de ir analizando y ejecutando el bytecode obtenido. Pero el ByteRun no es capaz ir almacenando las operaciones que va traduciendo, En este momento es donde se debe implementar una nueva funcionalidad en el interprete para que sea capaz de hacer esto, para asi mas tarde poder hacer un calculo de  la eficicencia.

\subsection{El Diccinario de procesos}.
Cuando el ByteRun lee una instruccion y lo primero que tiene que hacer es identificar que tipo de instruccion esta leyendo, hay muchos tipos diferentes desde un LOAD, a un LOOP, o un ADD, pero a nosotros no nos interesan todas las instrucciones, solo queremos almacenar aquellas que son consideradas por nosotros como "operaciones", o lo que es lo mismo, instrucciones que necesiten de algun tipo de calculo por parte del procesador, y que por lo tanto tenga un tiempo de ejecución.

Por suerte para nosotros el interprete ya hace distinciones entre los diferentes tipos de instrucciones y guarda en una lista todos aquellos valores en los cuales requiere hacer una operacion.

Aprovechando esto, cada vez que alguno de esas instrucciones es llamada guardamos el nombre que que tiene esta al ser visualizado el bytecode mediante el comando dis** en un diccionario, el cual decidimos llamas diccionario de operacciones.

Este diccionario tiene la siguiente estrucctura:

Imagen ejemplo

Se trata de un diccionario compuesto por una lista de clave primaria, y los componentes de esta lista son los siguiente:
Nombre de la operacion detectada por la interfaz
Primeras 3 Iniciales del tipo del primer operador 
Primeras 3 Iniciales del tipo del segundo operador 

Esta estructura de clave se basa en el hecho de que un operacion necisita de dos valores con los que operar, y dependiendo de el tipo de estos valores dos mismas operaciones con diferentes valores, pueden llegar a tener nivel de eficiencia mucho mas bajo o alto que el otro. 

Segun el ByteRun va analizando todo el codigo cuando detecta una instruccion dentro de la lista de operaciones este llama a una funcion que en caso de  no tener ninguna entrada de esa operacion y sus respectivos valores la genera y pone de valor un 1. Posteriormente si se va encontrando mas operaciones iguales en vez de  crear otra entrada en el diccionario de operaciones, incrementa en 1 el valor enlazado con la clave que la corresponde.

De esta manera cuando el ByteRun acaba de analizar todas las operaciones, conseguimos tener un diccionario contodas las operaciones que han surgido a lo largo de la ejecución del programa.

\subsection{Ponderación}.

Pero con solo tener los tipos de operaciones no es sufiente, para hacer un analisis de la eficiencia es necesario saber el nivel de eficiencia que dispone cada tipo de operacion, ya que no todas las operaciones tiene la misma commplejidad y el procesor necesita hacer mas calculos para ejecutarlos. Esto se consigue gracias a el procesador teorico.

\subsubsection{Procesadores Teoricos}
El procesador teorico tiene la funcion de darle un nivel de eficiencia a cada tipo de operacion. Se le puso este nombre por ser la parte que simula la complegidad que le supondria a un determminado procesdor, de esta mera segun los valores que se guarden en el procesaddor se pueden simuular diferentes tipos de entornos.

Estos procesadores se tratan de unos ficheros de tipo .csv que guardan una matriz, llamada matriz de traduccion, la cual esta hecha de taltiene una estructura pensada para poder sacar mas los  niveles de eficiencia  que guarda en cada celda segun sea necesario.

La dos primeras celdas de la matriz hacen de indice para las tuplas, la primera columna guarda el tipo de operacion mientras que la segunda guarda el tipo del primer operador. Siguiendo esta estructura si tuviéramos por ejemplo una suma de un entero con un decimal, para encontrar el nivel de eficiencia que habría que aplicarle a esta operacion en concreto la herramienta busca primero el tipo del operador, en este caso seria "ADD" y seguido a  esto busca en la segunda columna deja el valor "int", una vez  encontrados  estos dos valores ya tendria localizada la tupla dondese encuantra  el valor  deseado, y aqui es donde  entra en juego el indice de las  columnas que se haya en la primera filla de la matriz, esta  guarda los diferentes tipos que puede tomar el segundo operador, en este caso "flo", y con esto puede localizar que celda de la tupla es la que se necesita.

Foto ejemplo

\subsubsection{Pondera}
Una vez tenemos tanto el diccionario de operaciones como un Procesador teorico ya solo falta realizar la ponderación para obtener los datos necesarios para hacer los analisis oportunos. 

La manera en que se hace esto es bastante simple, consiste en darle un valor a cada  tipo de operacion
(sumatorio)
formulario

ejemplo

\section{Tipos de Analisis}
Con los datos obtenidos ya se pueden hacer diferentes tipos de analisis, en el caso de esta herramienta se han implementado dos tipos:
\begin{itemize}
	\item Analisis individual
	\item Analisis comparativo
\end{itemize}
 

\subsection{Analisis Individual}
En este análisis solo se permite la entrada de un fichero,de formato .py, el cual tras pasar por los pasos citados en los puntos anteriores, muestra una gráfica circular con las diferentes operaciones que el interprete(ByteRun)a detectado al ejecutarlo. Y ademas de esto  deja re calcular el resultado mostrado en el gráfico según las operaciones que queramos mostrar o no y el procesador  con el que se quiera hacer la ponderación.\\

Este aáalisis esta pensado para optimizar el código del programa, ya que de esta manera puedes detectar que operaciones son las que mas recursos consumen.

\subsection{Analisis Individual}
En este análisis se deben elegir mas de un fichero, los cuales ejecuta y calcula los ciclos de reloj que tarda en ejecutarse cada uno, pero al mostrar los resultados varia según el numero  de ficheros que  se hayan escogido. En caso de ser menos de 10 saldrá una gráfica de barras en la cual cada barra representa el total de ciclos de reloj de cada fichero. Y en caso de que se metan mas de 10 se cambiaría por una  gráfica de puntos para facilitar la visibilidad de los resultados. Al igual que en el análisis  individual en todo momento se pueden cambiar los resultados  de la gráfica cambiando las operaciones que queramos que se tengan en cuenta y el procesador  con el que se quiera ponderar las operaciones.\\

Este análisis esta pensado para compara ficheros que tengan como finalidad hacer lo mismo, y de esta manera saber cual de ellos tiene en que clase de entornos mejor eficiencia.



Como bien indica el nombre, la forma decidida para esto es un diccionario